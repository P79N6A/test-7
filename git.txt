git checkout -b local_name origin/remote_name #基于远程分支在本地新建分支，并切换到新分支  当不成功时，说明本地repo还不能感知到该远程分支, git remote update  ,  git update 更新一下跟踪信息
git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
git checkout master #切换到mater分支




----
Git checkout -- + 需要恢复的文件名

但是，需要注意的是，如果该文件已经 add 到暂存队列中，上面的命令就不灵光喽
需要先让这个文件取消暂存：

git reset HEAD -- + 需要取消暂存的文件名

然后再使用第一条命令。

如果感觉命令多了记不住，那就做一两个匿名呗，比如：

git config --global alias.unstage 'reset HEAD --'
git config --global alias.restore 'checkout --'

我们拿 README.md 这个文件举例，比如修改了一段文字描述，想恢复回原来的样子：

git restore README.md

即可，如果修改已经被 git add README.md 放入暂存队列，那就要

git unstage README.md
git restore README.md
-----

git branch #列出本地分支
git branch -r #查看所有远程分支
git branch -a #查看所有分支 包括远端仓库的分支
git branch -a -v #查看本地和远端仓库的所有分支，并显示最后一次提交
git clone -b <branch> <remote_repo> #clone 远端仓库的某个分支
git clone -b dev git@github.com:stephenykk/test.git #clone远端仓库的dev分支到本地
git branch new_branch
git branch -d merged_branch
git branch -D unmerged_branch

git diff <branch1>..<branch2> #分支比较

git diff HEAD HEAD^ --name-only #比较两次提交的差异 仅列出文件名

git remote show origin #显示远端仓库的详细信息(fetchUrl pushUrl, branches, "local branches configured for 'git pull'" , "local refs configured for 'git push' ")
git remote -v #查看远端仓库的配置信息
git remote update

git fetch
git fetch origin remote_branch_name:local_branch_name #把远程分支取回本地分支中


git push #推送所有分支到远端
git push origin localBranchName:removeBranchName #只推送 当前分支 到 远端对应分支


cat -n .git/config

git log --since="1 day ago" #查看1天前到现在的提交日志
git log -- somefile.html #查看某文件的更新历史
git log -p -- somefile.html #某文件明细更新历史
git log -1 -p -- somefile.html #查看某文件上次的修改内容
git log -- f1.html f2.html
git log -- folder/ 
git log -3 dev #查看dev分支最近3次的提交日志
git log v1.0.. #查看v1.0后的提交日志


1. 撤销working tree的修改
git reset --hard HEAD # HEAD, index和working tree都重置为最后一次commit的状态

2. 撤销staged状态
git reset HEAD #index tree回退到最后一次commit的状态

3.本地修改文件后，不希望commit到远端仓库可以这样
git commit -m "commit part of changes" -- folderName_or_fileName



---------------------------------
查看、添加、提交、删除、找回，重置修改文件

git help <command> # 显示command的help

git show # 显示某次提交的内容 git show $id

git co -- <file> # 抛弃工作区修改

git co . # 抛弃工作区修改

git add <file> # 将工作文件修改提交到本地暂存区

git add . # 将所有修改过的工作文件提交暂存区

git rm <file> # 从版本库中删除文件

git rm <file> --cached # 从版本库中删除文件，但不删除文件

git reset <file> # 从暂存区恢复到工作文件

git reset -- . # 从暂存区恢复到工作文件

git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am "some comments"

git ci --amend # 修改最后一次提交记录

git revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象

git revert HEAD # 恢复最后一次提交的状态

查看文件diff

git diff <file> # 比较当前文件和暂存区文件差异 git diff

git diff <id1><id1><id2> # 比较两次提交之间的差异

git diff <branch1>..<branch2> # 在两个分支之间比较

git diff --staged # 比较暂存区和版本库差异

git diff --cached # 比较暂存区和版本库差异

git diff --stat # 仅仅比较统计信息

查看提交记录

git log git log <file> # 查看该文件每次提交记录

git log -p <file> # 查看每次详细修改内容的diff

git log -p -2 # 查看最近两次详细修改内容的diff

git log --stat #查看提交统计信息

tig

Mac上可以使用tig代替diff和log，brew install tig

Git 本地分支管理

查看、切换、创建和删除分支

git br -r # 查看远程分支

git br <new_branch> # 创建新的分支

git br -v # 查看各个分支最后提交信息

git br --merged # 查看已经被合并到当前分支的分支

git br --no-merged # 查看尚未被合并到当前分支的分支

git co <branch> # 切换到某个分支

git co -b <new_branch> # 创建新的分支，并且切换过去

git co -b <new_branch> <branch> # 基于branch创建新的new_branch

git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除

git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支

git br -d <branch> # 删除某个分支

git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)

 分支合并和rebase

git merge <branch> # 将branch分支合并到当前分支

git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交

git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> && git rebase master && git co master && git merge <branch>

 Git补丁管理(方便在多台机器上开发同步时用)

git diff > ../sync.patch # 生成补丁

git apply ../sync.patch # 打补丁

git apply --check ../sync.patch #测试补丁能否成功

 Git暂存管理

git stash # 暂存

git stash list # 列所有stash

git stash apply # 恢复暂存的内容

git stash drop # 删除暂存区

Git远程分支管理

git pull # 抓取远程仓库所有分支更新并合并到本地

git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并

git fetch origin # 抓取远程仓库更新

git merge origin/master # 将远程主分支合并到本地当前分支

git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支

git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上

git push # push所有分支

git push origin master # 将本地主分支推到远程主分支

git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)

git push origin <local_branch> # 创建远程分支， origin是远程仓库名

git push origin <local_branch>:<remote_branch> # 创建远程分支

git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支

Git远程仓库管理

GitHub

git remote -v # 查看远程服务器地址和仓库名称

git remote show origin # 查看远程服务器仓库状态

git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址

git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库

创建远程仓库

git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库

scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上

mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库

git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址

git push -u origin master # 客户端首次提交

git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track

git remote set-head origin master # 设置远程仓库的HEAD指向master分支

也可以命令设置跟踪远程库和本地库

git branch --set-upstream master origin/master

git branch --set-upstream develop origin/develop




----------
git clone remote_repo <local_dir>?
支持协议 http(s)://, ssh://, git://, file:///, ftp(s)://, rsync://
git clone [user@]example.com:path/to/repo.git
git clone git@github.com:stephenykk/test.git

git clone -o jq https://github.com/jquery/jquery.git
git remote //=> jq
git remote -v
git remote add origin repo_url
git remote rm origin
git remote rename origin newOrigin

git fetch  //默认会取回所有分支的更新 所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取

git fetch <remote_repo> <branch_name> //只取回指定分支的更新
git fetch origin master
git checkout -b newBranch origin/master //在取回的远程分支(origin/master)的基础上， 创建分支

git merge origin/master
或
git rebase origin/master //合并 orgin/master到当前分支


git branch -r //查看远程分支
git branch -a //查看所有分支(包括远程和本地)


git pull <远程主机名> <远程分支>:<本地分支>
git pull origin next:master //比如，取回origin主机的next分支，与本地的master分支合并

git pull origin next //取回origin/next分支，再与当前分支合并。
等价于
git fetch origin next
git merge origin/next


在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动"追踪"origin/master分支。
Git也允许手动建立追踪关系。

git branch --set-upstream master origin/next  //指定master分支追踪origin/next分支。

如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。
git pull origin  //会pull所有有追踪关系的分支吧？

如果当前分支只有一个追踪分支，连远程主机名都可以省略。
git pull
如果合并需要采用rebase模式，可以使用--rebase选项。
git pull --rebase <远程主机名> <远程分支>:<本地分支>

加上参数 -p 就会在本地删除远程已经删除的分支。
git pull -p
#等价于
git fetch --prune origin
git fetch -p

git push <远程主机名> <本地分支>:<远程分支>

如果省略远程分支名，则表示将本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。
git push origin master

如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。
git push origin :master
#等同于
git push origin --delete master

如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。
git push origin

如果当前分支只有一个追踪分支，那么主机名都可以省略。
git push

git push -u origin master //令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了


不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。


$ git config --global push.default matching
# 或者
$ git config --global push.default simple








**************************************************

你不小心，写错了提交的注视/信息，该如何处理呢。理论上，SCM是不应该修改历史的信息的，提交的注释也是。 
  不过在Git中，其commit提供了一个--amend参数，可以修改最后一次提交的信息.但是如果你已经push过了，那么其历史最后一次，永远也不能修改了。 
  我使用git commit --amend已经push过的，截图如下，我那个"fixes #3"永远的在版本历史中了。
 git commit --amend
的用法，，，
# git commit --amend
然后在出来的编辑界面，直接编辑 注释的信息。。
===========================================================================================================
===========================================================================================================
git修改历史提交
2011-06-16 17:58
       git使用amend选项提供了最后一次commit的反悔。但是对于历史提交呢，就必须使用rebase了。
       git rebase -i HEAD~3
       表示要修改当前版本的倒数第三次状态。
        这个命令出来之后，会出来三行东东：
        pick:*******
        pick:*******
        pick:*******
        如果你要修改哪个，就把那行的pick改成edit，然后退出。
 
        这时通过git log你可以发现，git的最后一次提交已经变成你选的那个了，这时再使用：
        git commit --amend
        来对commit进行修改。
        修改完了之后，要回来对不对？
        使用git rebase --continue
        OK，一切都搞定了。

==============================================================
Git修改前一次提交的方法(特别注意保持Change-Id不变)
2011年8月8日sinojelly发表评论阅读评论
如果发现上一次提交的内容存在问题，就需要修改了。
基本概念
Change:
Gerrit中的一个Change就是一个Review任务，它对应一个commit。
每个commit，应该是为了一个目的的完整修改。如果某一次修改不完全，就需要修正该commit。
每一次修正之前的commit，重新提交时，都应该保持Change-Id不变，这样就不会产生新的Change，而是在原有的Change下产生一个新的Patch Set。
所有的Patch Set中，只有最新的一个是真正有用的，能够合并的。
图1：Change和Change-Id


图2：Patch Set


修改前一次提交的方法
方法一：用Camend选项
#修改需要修改的地方。
git add .
git commit Camend
注：这种方式可以比较方便的保持原有的Change-Id，推荐使用。

方法二：先reset，再修改
这是可以完全控制上一次提交内容的方法。但在与Gerrit配合使用时，需特别注意保持同一个commit的多次提交的Change-Id是不变的。
否则，就需要Abondon之前的Change，产生一些垃圾不说，操作得不对，会使得简单的事情复杂化，甚至无法合并。
git reset HEAD^
#重新修改
git add .
git commit -m “MSG”
特别注意：为了保持提交到Gerrit的Change不变，需要复制对应的Change-Id到commit msg的最后，可以到Gerrit上对应的Change去复制，参见图1。

方法三：只是修改作者
如果email不对，会无法提交到Gerrit，所以这个命令也可能用到。
git commit Camend Cauthor=<user-email>
注：如果该email地址从未有过成功的提交，这个修改会不成功。在别的分支做一次成功提交之后，就可以修改了。




=========================================================
1. // 查看修改

git rebase -i master~1 //最后一次
git rebase -i master~5 //最后五次

2. // 显示结果如下，修改 pick 为 edit ，并 :wq 保存退出

pick 92b495b 2009-08-08: ×××××××

# Rebase 9ef2b1f..92b495b onto 9ef2b1f
#
# Commands:
#  pick = use commit
#  edit = use commit, but stop for amending //改上面的 pick 为 edit
#  squash = use commit, but meld into previous commit
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#


3. 命令行显示：

Rebasing (1/1)
You can amend the commit now, with

git commit --amend


4. 使用 git commit --amend 进行修改，完成后 :wq 退出

5. 使用 git rebase --continue 完成操作

-----------------
#从仓库删除文件
git rm -- yourfile  

--------
git diff --name-only HEAD^ HEAD # 查看上次提交的文件列表

git log --name-only -1 # 同上

--------
git submodule add 仓库地址 路径
其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 
注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能利 Clone）
命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。

删除
submodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm Ccached ”命令将子模块所在的文件从git中删除。

下载的工程带有submodule
当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：
git submodule update --init --recursive
即可将子模块内容下载下来后工程才不会缺少相应的文件。

----
抽取项目公共模块，多项目共用，必然会使用到Git submodule命令。 
项目中submodule的管理，无外乎添加，更新，删除等操作。

1. submodule 添加

进入到git项目根目录下，输入命令:

git submodule add [-b master ] [URL to Git repo] [local path]
其中，[-b master] 为submodule的默认分支，[local path]为submodule的本地路径。

命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息，
cat -n .gitmodules  #查看子模块信息

[submodule "libraries/pushserver"]
 path = libraries/pushserver                //本地路径
 url = git@*****/android-library-push.git   //仓库地址
 branch = master                            //默认分支

2. submodule 更新

若项目中包含.gitmodules, 进入到git项目根目录下，输入命令, .gitmodules中的所有项目都会进行更新:

git clone 父项目.git 
git submodule init 
git submodule update (update时，submodule分支必须已在正确分支上)

submodule远程分支发生变更后，直接使用git submodule update是不会进行更新操作的。必须依次进入到各个submodule的目录，进行git pull操作，如果submodule数目很多，每次发版本时必须进入所有目录进行git pull，这将是噩梦。不过有个更简单的方法，

git submodule foreach git checkout master 
git submodule foreach git pull

3. submodule 删除

删除submodule会麻烦些，仅仅删除submodule模块内容，是无法彻底从git中删除掉。还需要到git相关配置文件中删除条目。

删除 [项目根目录/.gitmodules] 中对应的条目
删除 [项目根目录/.git/config] 中对应的条目
删除 [项目根目录/.git/modules] 目录下的对应的submodule文件夹
执行 git rm Ccached [modulename] 命令
删除 submodule 模块内容


-----

git clean #删除那些未被跟踪(untracked)的文件

-n 显示 将要 删除的 文件 和  目录

-f 删除 文件，-df 删除 文件 和 目录


git clean -n

git clean -df

git clean -f


git rm #把一个文件从硬盘删除，并从git仓库移除。但是注意最后要执行git commit才真正提交到git仓库

git rm 1.txt  #删除1.txt文件，并把它从git的仓库管理系统中移除。

git rm -r myFolder #删除文件夹myFolder，并把它从git的仓库管理系统中移除。



git cherry-pick用于把另一个本地分支的commit修改应用到当前分支。
实际问题 
  在本地 master 分支上做了一个commit ( 38361a68138140827b31b72f8bbfd88b3705d77a ) ， 如何把它放到 本地 old_cc 分支上？ 
使用 cherry-pick, 对已经存在的commit 进行apply (可以理解为再次提交）
简单用法：
git cherry-pick <commit id>
$ git checkout old_cc
$ git cherry-pick 38361a68

------
git stash: 

备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。

git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stas中读取内容并恢复。
git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。

关于Git Stash的详细解释，适用场合，这里做一个说明：
使用git的时候，我们往往使用branch解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码 commit提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用'git stash'就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完Bug，提交到服务器上后，再使用'git stash apply'将以前一半的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用'git stash'命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，'git stash list'命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用'git stash apply stash@{1}'就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回来的时候，可以使用'git stash clear'来将栈清空。
在这里顺便提下git format-patch -n , n是具体某个数字， 例如 'git format-patch -1' 这时便会根据log生成一个对应的补丁，如果 'git format-patch -2' 那么便会生成2个补丁，当然前提是你的log上有至少有两个记录。

看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时Boss来了，说前面的分支上面有一个Bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法checkout到前面的分支。此时用Git Stash就相当于备份工作区了。然后在Checkout过去修改，就能够达到保存当前工作区，并及时恢复的作用。
